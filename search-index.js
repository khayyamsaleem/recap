var searchIndex = JSON.parse('{\
"recap":{"doc":"Recap deserializes structures from regex named capture …","t":[6,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["Error","Regex","as_str","borrow","borrow_mut","capture_locations","capture_names","captures","captures_iter","captures_len","captures_read","captures_read_at","clone","clone_into","find","find_at","find_iter","fmt","fmt","from","from_captures","from_str","into","is_match","is_match_at","new","replace","replace_all","replacen","shortest_match","shortest_match_at","split","splitn","to_owned","to_string","try_from","try_into","type_id"],"q":["recap","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["A type which encapsulates recap errors","A compiled regular expression for matching Unicode strings.","Returns the original string of this regex.","","","Returns an empty set of capture locations that can be …","Returns an iterator over the capture names.","Returns the capture groups corresponding to the …","Returns an iterator over all the non-overlapping capture …","Returns the number of captures.","This is like <code>captures</code>, but uses <code>CaptureLocations</code> instead of","Returns the same as captures, but starts the search at the …","","","Returns the start and end byte range of the leftmost-first …","Returns the same as find, but starts the search at the …","Returns an iterator for each successive non-overlapping …","Shows the original regular expression.","Shows the original regular expression.","","Deserialize a type from named regex capture groups","Attempts to parse a string into a regular expression","","Returns true if and only if there is a match for the regex …","Returns the same as is_match, but starts the search at the …","Compiles a regular expression. Once compiled, it can be …","Replaces the leftmost-first match with the replacement …","Replaces all non-overlapping matches in <code>text</code> with the …","Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> …","Returns the end location of a match in the text given.","Returns the same as shortest_match, but starts the search …","Returns an iterator of substrings of <code>text</code> delimited by a …","Returns an iterator of at most <code>limit</code> substrings of <code>text</code> …","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[null,null,[[],["str",15]],[[]],[[]],[[],["capturelocations",3]],[[],["capturenames",3]],[[["str",15]],[["captures",3],["option",4,["captures"]]]],[[["str",15]],["capturematches",3]],[[],["usize",15]],[[["capturelocations",3],["str",15]],[["match",3],["option",4,["match"]]]],[[["usize",15],["capturelocations",3],["str",15]],[["match",3],["option",4,["match"]]]],[[],["regex",3]],[[]],[[["str",15]],[["match",3],["option",4,["match"]]]],[[["usize",15],["str",15]],[["match",3],["option",4,["match"]]]],[[["str",15]],["matches",3]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[]],[[["str",15],["regex",3]],["result",6]],[[["str",15]],[["error",4],["regex",3],["result",4,["regex","error"]]]],[[]],[[["str",15]],["bool",15]],[[["str",15],["usize",15]],["bool",15]],[[["str",15]],[["error",4],["regex",3],["result",4,["regex","error"]]]],[[["str",15]],[["str",15],["cow",4,["str"]]]],[[["str",15]],[["str",15],["cow",4,["str"]]]],[[["usize",15],["str",15]],[["str",15],["cow",4,["str"]]]],[[["str",15]],[["usize",15],["option",4,["usize"]]]],[[["str",15],["usize",15]],[["usize",15],["option",4,["usize"]]]],[[["str",15]],["split",3]],[[["usize",15],["str",15]],["splitn",3]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]]],"p":[[3,"Regex"]]},\
"recap_derive":{"doc":"","t":[24],"n":["Recap"],"q":["recap_derive"],"d":[""],"i":[0],"f":[null],"p":[]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};